# 3DSoloProject1
 3DSoloProject1

1.
Player : 플레이어가 가지고 있어야하는 모든 컴포넌트(정보)를 가지고 있는 스크립트
CharacterManger : 플레이어가 존재하는지, 그렇다면 그게 누구인지 알려주는 싱글톤 구조

플레이어는 존재할 수 있고 안할 수 있다. 
매번 플레이어의 존재를 FindComponetbytype 같은 기능을 사용하면 시간이나 메모리적으로 불필요한 작업을 하게된다.
하지만 CharacterManger의 Player가 null인지 아닌지의 체크로 쉽게 파악할 수 있다.
또한 Player를 바로 참조하는 경우 컴포넌트를 찾지 못해서 오류가 발생 할 수 있지만, CharacterManger에서 먼저 체크를 해준다면, 오류를 줄일 수 있을 것이다.
씬이 변경되어 오브젝트가 사라지면 연결이 끊기게 된다. 
하지만 Player 스크립트를 가진 객체를 생성하면 거기에 있는 awake문이 실행되면서 스스로의 정보를 다시 할당해 줄 수 있다.
그렇기 때문에 만약에 플레이어가 사용되지않는 scene이 있다면, 불필요한 값을 가지지 않고 플레이어가 존재하는 씬에서만 플레이어의 정보를 저장할 수 있다.
게다가 플레이어가 변경(기존 player를 제거하고 새로운 player 생성 시)되면 바로 바뀐 정보를 사용할 수 있다.

(Behavior : sendMessage)
Move의 기능은 이전 강의에서는 바로 wasd의 값을 설정하고 정해진 변수명 OnMove를 통해서 받은 값(inputValue)의 Vector2값을 활용해서 바로 이동시켰다.

 -> (Behavior : Innvoke Unity Event)
하지만 이번 강의의 경우, 플레이어 인풋에서 Button의 기능을 설정해 주는 것 같이 연결을 시켜준다.
정해진 변수 명이 아니라 기능을 만들고 위에서 설정한 기능에 붙여서 원하는 기능을 수행하게 할 수 있다.
이 경우 어떤 스크립트가 어떤 기능을 하는지 외부에서 바로 확인이 가능하고 이후에 변경이나 추가에 용이해 보인다.

Move의 경우 입력받은 방향을 정면(화면)을 기준으로 이동하고
CameraLook의 경우 순간적으로 입력받은 마우스의 변화량(cursor.delta?) 만큼 화면을 회전 시켜준다.
isGrounded 플레이어 바닥 4방향을 향햐서 특정 길이(매우 짧음) 만큼의 레이를 쏴서 레이가 닿으면 땅에 있다고 가정해서 점프가능 여부를 결정

Move의 경우 컴퓨터의 성능에 따른 프레임같은 변수에 따라서 이동하는 거리가 달라져서는 안된다. 그래서 Time.delta같은 기능을 사용해서 정해진 프레임마다 실행하는 FixedUpdate 기능을 사용해서 구현하면
모두가 동일한 이동경험을 얻을 수 있다.
CameraLook이 사용하는 LateUpdate는 모든 update가 실행된 후 마지막에 실행하는 update이다. 
LateUpdate를 사용하면 이동이나 다른 작업이 끝난후 화면을 이동해 더 자연스러운 화면을 보여줄 수 있다.


2.
UI의 변경점을 관리할 하나의 스크립트가 필요하기 때문에, 
변경해야하는 값은 Player에서 연결해준다.

인터페이스로 구성하는 요소는 서로 다른 오브젝트들이 가지는 공통의 기능에 좋다(IDamageable,IIteractable)
기능은 전혀 다르더라도 특정 상황에서 발생하는 이벤트들을 미리 정의만 해두고,
해당 오브젝트의 스크립트에서 정확한 기능을 만들어 주면, 인터페이스 명을 통한 호출로 각자의 기능을 수행 할 수 있다.

itemObject에 있는 인터페이스의 경우 두개의 기능이 있다.
아이템 정보를 화면에 나타내는 GetInteractPrompt, 상호작용 키를 누르면 발동하는 OnInteract
OnInteract의 경우 Player 스크립트에 존재하는 Action Additem 제네릭? 을 호출한다. 
현재에는 상호작용 시 회득하는 아이템만 존재하기에 itemObject 스크립트에서만 사용하지만, 
문이나 특정 기능을 수행하는 아이템을 만든다면 새로운 스크립트를 만들고 IInteractable을 상속해서 UI를 띄우거나 다른 기능을 사용할 수 있을 것 같다.

UI스크립트(HP,Hunger) : UI 창에 캐릭터의 정보에 따라 초기 값이 정해지고 시간이 지남에 따라 변화하는 값을 넣어준다.
플레이어의 정보에 저장 되어야하기 때문에 인터페이스에서 플레이어를 찾아서 자신의 값을 연결해준다.

CampFire : IDamageable을 상속받는(가지고 있는) 오브젝트에게 특정 주기마다 피해를 준다. 자신이 IDamageable에게 피해를 주는 기능만 구현해 놓으면
이후에 어떠한 객체를 만들어도 IDamageable을 상속한다면, campfire는 정해진 피해를 줄 수 있다.

DamageIndicator : Player가 피해를 받는 순간 수행하는 제네릭 OnTakeDamage에 연결해서 사용. 화면이 순간적으로 변했다가 돌아온다.
이를 활용하면 나중에 피해를 받을 때, 특정 소리가 발생하거나 다른 특수효과를 주고 싶을때, OnTakeDamage에 연결만 해주면 된다. 

3.
Interaction은 지속적으로 바라보는 아이템의 정보를 나타내주는 로직과 상호작용 키를 누르면 
해당 아이템 정보를 인벤토리에 넣어주는 로직이 있다.
첫번째 기능은 플레이어 기준에서 Ray를 쏴주어서 부딫힌 대상의 Layer를 체크해서 아이템의 레이어인 경우
해당 오브젝트의 데이터SO에 접근하여서 원하는 정보를 출력해준다.
두번쩨 기능은 상호작용한 아이템SO를 인벤토리에 있는 slots에 저장한 뒤, 스프라이트나 텍스트를 변경해줘서 가지고 있는 아이템의 정보와 갯수를 학인할 수 있다.

Inventory는 처음 기동시 모든 정보를 초기화 해주고,
interaction에서 전달한 아이템SO를 빈 slot에 전달해준다.
그리고 아이템이 존재하는 slot을 클릭하면 해당 아이템의 정보를 인벤토리 창에 출력해 준다.
